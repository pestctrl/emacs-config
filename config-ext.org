#+PROPERTY: header-args:emacs-lisp :tangle "~/.emacs.d/config-ext.el" :comments both

* window manipulation
#+begin_src emacs-lisp
  ;; The prefix
  (define-prefix-command '*window-map*)
  (define-key *root-map* (kbd "w") '*window-map*)

  ;; Side-window stuff
  (use-package resize-window)
  (require 'side-window-split)
  (define-key *window-map* (kbd "j") 'side-bottom-window)
  (define-key *window-map* (kbd "h") 'side-left-window)
  (define-key *window-map* (kbd "k") 'side-top-window)
  (define-key *window-map* (kbd "l") 'side-right-window)
  (define-key *window-map* (kbd "d") 'side-window-delete-all)
  (define-key *window-map* (kbd "r") 'resize-window)

  ;; Dedicated window
  (defun my/toggle-dedicated-window ()
    (interactive)
    (let ((win (selected-window)))
      (set-window-dedicated-p win (not (window-dedicated-p win)))))
#+end_src
* Various tools
** ledger
#+begin_src emacs-lisp
  (use-package ledger-mode
    :mode "\\.dat\\'"
    :config
    (setq ledger-narrow-on-reconcile nil)

    (setq ledger-reports
          `(("account" "%(binary) -f %(ledger-file) reg %(account)")
            ("credit card" "%(binary) -f %(ledger-file) reg %(account) --aux-date --sort -d")
            ("bal" "%(binary) -f %(ledger-file) bal")
            ("reg" "%(binary) -f %(ledger-file) reg")
            ("equity" "%(binary) -f %(ledger-file) bal ^Exp ^RE ^Rev")
            ("uncleared" "%(binary) -f %(ledger-file) reg --uncleared --limit=\"payee!='Texas Instruments Income'\"")
            ("last-superfluous" "%(binary) -f %(ledger-file) bal --limit='account =~ /^Exp:(Food|Luxury|NewTech|People)/ && date >= [this month]'")
            ("superfluous" "%(binary) -f %(ledger-file) reg --limit='account =~ /^Exp:(Food|Luxury|NewTech|People)/'")
            ("recurring" "%(binary) -f %(ledger-file) reg --limit='has_tag(\"RECURRING\")' ^Exp")
            ("expmonth" "%(binary) -f %(ledger-file) -M reg Expenses")
            ("owedmom" "%(binary) -f %(ledger-file) reg Liabilities")
            ("progress" "%(binary) -f %(ledger-file) reg Assets Equity Liabilities")
            ("payee" "%(binary) -f %(ledger-file) reg @%(payee)")
            ("lia1" "%(binary) -f %(ledger-file) bal ^Lia --cleared")
            ("lia2" "%(binary) -f %(ledger-file) reg ^Lia --uncleared")
            ("Ast:AR" "%(binary) -f %(ledger-file) bal ^Ast:AR")))

    (setq dynamic-reports
          '(("budgetcal" "%(binary) -f ~/MEGA/org/entries/food.ledger --daily --add-budget reg Expenses")))

    (defun ledger-dynamic-report ()
      (interactive)
      (let* ((ledger-reports dynamic-reports)
             (report-name (ledger-report-read-name)))
        (ledger-report report-name nil)))

    (setq ledger-reconcile-buffer-line-format
          "%(date)s %-4(code)s %-30(payee)s %-30(account)s %15(amount)s\n")

    (defun ledger-account-check-dont-include-regexp (orig account)
      (when (= (aref account 0)
               ?^)
        (setq account
              (substring account 1))))

    (defun ledger-report-show-monthly-average ()
      (interactive)
      (let ((average-string "-A -M -n"))
        (unless (string-match-p average-string ledger-report-cmd)
          (setq ledger-report-cmd
                (concat ledger-report-cmd " " average-string))
          (ledger-report-redo))))

    (setq ledger-amount-regexp
          (concat
           "\\(  \\|\t\\| \t\\)[ \t]*-?"
           "\\(?:" "?-" ledger-commodity-regexp " *\\)?"
           ;; We either match just a number after the commodity with no
           ;; decimal or thousand separators or a number with thousand
           ;; separators.  If we have a decimal part starting with `,'
           ;; or `.', because the match is non-greedy, it must leave at
           ;; least one of those symbols for the following capture
           ;; group, which then finishes the decimal part.
           "\\(-?\\(?:[0-9]+\\|[0-9,.]+?\\)\\)"
           "\\([,.][0-9)]+\\)?"
           "\\(?: *" ledger-commodity-regexp "\\)?"
           "\\([ \t]*[@={]@?[^\n;]+?\\)?"
           "\\([ \t]+;.+?\\|[ \t]*\\)?$"))

    (define-key ledger-report-mode-map (kbd "M") #'ledger-report-show-monthly-average)

    (defun my/ledger-complete-xact--remove-stars ()
      (interactive)
      (let* ((date-regexp (rx (and line-start (= 4 digit) "/" (= 2 digit) "/" (= 2 digit))))
             (start (save-excursion
                      (re-search-backward date-regexp)
                      (point)))
             (end (save-excursion
                    (or (re-search-forward date-regexp nil t)
                        (end-of-buffer))
                    (beginning-of-line)
                    (point))))
        (save-window-excursion
          (narrow-to-region start end)
          (beginning-of-buffer)
          (replace-regexp "    \\* " "    ")
          (widen))))

    (advice-add #'ledger-fully-complete-xact
                :after
                #'my/ledger-complete-xact--remove-stars))
#+end_src
** Credit Card Statement Macro
#+begin_src emacs-lisp
  (fset 'credit_card_statement
     [?\M-x ?o ?r ?g ?- ?m ?o ?d ?e return ?\M-x ?q backspace ?r ?e ?p ?l ?a ?c ?e ?- ?r ?e ?g ?e ?x ?p return ?^ ?\C-q tab return ?  ?  ?  ?  return ?\M-< ?\C-  ?\C-f ?\C-f ?\C-f ?\C-f ?\C-c ?m ?a ?\C-w ?- ?  ?\[ ?  ?\] ?  ?\C-e ?\C-k ?\C-c ?m ?  ?\C-q tab ?\C-q tab ?\C-e ?\C-j ?y ?\C-a ?_ ?_ ?_ ?_ backspace backspace backspace backspace ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?= ?\C-p ?\C-p ?\C-k ?\C-c ?m ?  ?\C-q tab ?\C-q tab ?\C-d ?\C-d return ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n ?\C-n])
#+end_src
** encryption
#+begin_src emacs-lisp
  (require 'epa-file)
  (epa-file-enable)
  (setq epa-pinentry-mode 'loopback)
  (setq epa-file-cache-passphrase-for-symmetric-encryption t)
  (setenv "GPG_AGENT_INFO" nil)

  (setq epg-gpg-program "gpg2")
  (setq auth-source-debug t)
  (setq auth-sources '((:source "~/.emacs.d/secrets/.authinfo.gpg")))
#+end_src
** email
#+begin_src emacs-lisp
  (setq user-mail-address "bensonchu457@gmail.com"
        user-full-name "Benson Chu")

  (setq smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        send-mail-function 'smtpmail-send-it
        message-send-mail-function 'smtpmail-send-it)

  (mailcap-add "text/html" "/usr/bin/xdg-open %s ")

  (setq mail-specify-envelope-from t
        message-sendmail-envelope-from 'header
        mail-envelope-from 'header)

  (use-package notmuch
    :commands notmuch
    :bind (:map notmuch-message-mode-map
                ("C-c C-c" . #'my/choose-email-address-and-send)
                :map notmuch-search-mode-map
                ("z" . #'notmuch-search-tree-current-thread)
                ("A" . #'notmuch-search-show-all)
                ("D" . #'notmuch-search-delete-all)
                ("f" . #'notmuch-search-filter-for-domain)
                ("F" . #'notmuch-search-filter-for-sender)
                ("<mouse-1>" . nil)
                :map notmuch-tree-mode-map
                ("<tab>" . #'notmuch-tree-explore-here)
                ("<down>" . #'notmuch-tree-next-message)
                ("<up>" . #'notmuch-tree-prev-message)
                ("d" . #'my/notmuch-delete-mail)
                ("U" . #'notmuch-tree-unfold-all)
                ("u" . #'notmuch-tree-up-thread)
                ("N" . #'notmuch-tree-next-sibling)
                ("P" . #'notmuch-tree-prev-sibling)
                ("t" . #'notmuch-tree-toggle-folding-thread)
                ("/" . #'notmuch-tree-undo-read)
                ("F" . #'notmuch-tree-focus)
                ("S-SPC" . #'notmuch-tree-scroll-message-window-back))
    :config
    (require 'notmuch-nav)
    (require 'notmuch-tree-hide)
    (require 'notmuch-tree)
    (require 'notmuch-fold)

    (setq notmuch-draft-tags '("+drafts"))

    (custom-set-faces
     '(notmuch-tree-match-tree-face ((t (:family "Source Code Pro"))) t)
     '(notmuch-tree-no-match-tree-face ((t (:family "Source Code Pro"))) t))
    (set-face-attribute 'notmuch-search-unread-face nil :foreground "white")
    (set-face-attribute 'notmuch-message-summary-face nil :background "steel blue" :foreground "snow")
    (add-to-list 'notmuch-search-line-faces
                 '("deleted" . font-lock-comment-face))

    (defun notmuch-search-show-all ()
      (interactive)
      (let* ((query (replace-regexp-in-string "date:[^ ]+" "" notmuch-search-query-string))
             (noand (replace-regexp-in-string "^ *and +" "" query))
             (noand2 (replace-regexp-in-string " +and *" "" query)))
        (notmuch-search noand2)))

    (defun notmuch-search-tree-current-thread (arg)
      (interactive "P")
      (let* ((thread-id (notmuch-search-find-thread-id))
             (input (notmuch-read-query (concat "Notmuch tree: " thread-id " and "))))
        (notmuch-tree thread-id (unless (zerop (length input)) input) nil nil nil nil nil (unless arg #'notmuch-tree-hide-dead-trees))))

    (defun notmuch-tree-focus (arg)
      (interactive "P")
      (notmuch-tree notmuch-tree-basic-query (notmuch-tree-get-message-id) nil nil nil nil nil (if (not arg) #'notmuch-tree-hide-dead-trees #'notmuch-tree-show-trail-and-alive-children)))

    (defun notmuch-tree-undo-read (arg)
      (interactive "P")
      (if arg
          (save-excursion
            (beginning-of-buffer)
            (while (text-property-search-forward
                    'face 'notmuch-tag-deleted
                    #'(lambda (value prop)
                        (if (consp prop)
                            (member value prop)
                          (eq value prop))))
              (notmuch-tree-add-tag '("+unread"))))
        (notmuch-tree-add-tag '("+unread"))
        (next-line)))

    (setq notmuch-search-oldest-first nil
          notmuch-saved-searches
          '((:name "inbox" :query "tag:inbox" :key "i")
            (:name "inbox today" :query "date:2020-07-25.. and tag:inbox" :key "t")
            (:name "work" :query "tag:work" :key "w")
            (:name "mailing lists" :query "tag:mlist" :key "m")
            (:name "emacs-devel" :query "tag:emacs-devel" :key "e")
            (:name "emacs bugs" :query "tag:bug-gnu-emacs and date:30d.." :key "E")
            (:name "emacs help" :query "tag:help-gnu-emacs and date:30d.." :key "h")
            (:name "org-mode" :query "tag:org-mode" :key "o")
            (:name "recruiting" :query "tag:recruiting" :key "r")
            (:name "unread" :query "tag:unread" :key "u")
            (:name "flagged" :query "tag:flagged" :key "f")
            (:name "cs" :query "tag:cs" :key "c")
            (:name "receipts" :query "tag:receipts" :key "R")
            (:name "voicemail" :query "from:vm@italkbb.com" :key "v")
            ;; (:name "sent" :query "tag:sent" :key "s")
            ;; (:name "drafts" :query "tag:draft" :key "d")
            (:name "all mail" :query "*" :key "a")))

    (defun my/choose-email-address-and-send ()
      (interactive)
      (let ((resp (completing-read "Which email? " '("bchu3@cougarnet.uh.edu" "bensonchu457@gmail.com") nil t "^")))
        (setq smtpmail-smtp-server
              (if (string= resp "bensonchu457@gmail.com")
                  "smtp.gmail.com"
                "smtp.office365.com"))
        (notmuch-mua-send-and-exit)))

    (add-to-list 'notmuch-tagging-keys
                 '("R" ("-inbox" "+recruiting") "Recruiting"))

    (setf (cdr (assoc "d" notmuch-tagging-keys))
          '(("+deleted") "Delete"))

    (advice-add #'notmuch-tag-jump :after #'(lambda (&rest args) (next-line)))

    (defun notmuch-search-filter-for-domain ()
      (interactive)
      (notmuch-search-show-thread)
      (let* ((author (notmuch-show-get-from)))
        (notmuch-bury-or-kill-this-buffer)
        (string-match (rx (and (group (+ (not (any "." "@" "<")))
                                      "."
                                      (+ (not (any "." "@" "<" ">"))))
                               (or ">" eol)))
                      author)
        (notmuch-search-filter (format "from:%s" (match-string 1 author)))))

    (defun notmuch-search-filter-for-sender ()
      (interactive)
      (notmuch-search-show-thread)
      (let ((author (notmuch-show-get-from)))
        (notmuch-bury-or-kill-this-buffer)
        (notmuch-search-filter (format "from:%s" author))))

    (defun notmuch-search-delete-all ()
      (interactive)
      (let ((line-count (save-excursion (end-of-buffer) (line-number-at-pos (point)))))
        (when (or (< line-count 20)
                  (y-or-n-p "Are you sure? There seems to be a lot of emails... "))
          (notmuch-search-tag-all '("+deleted")))))

    (defun notmuch-add-child (child-id)
      (interactive (list (read-string (format "Message id of new child (default: %s): "
                                              (current-kill 0))
                                      nil nil (current-kill 0))))
      (let ((parent-id (notmuch-show-get-message-id t))
            (child-file
             (save-window-excursion
               (notmuch-show (format "id:%s" child-id))
               (notmuch-show-get-filename))))
        (with-current-buffer (find-file-noselect child-file)
          (beginning-of-buffer)
          (if (save-excursion (re-search-forward "^In-Reply-To: " nil t))
              (error "File already has reply message")
            (save-excursion
              (re-search-forward "^Date: ")
              (end-of-line)
              (insert (format "\nIn-Reply-To: <%s>"
                              parent-id))
              (save-buffer)))
          (re-search-forward "^Message-ID: <\\(.*\\)>$")
          (message (match-string 1)))
        (notmuch-refresh-file child-id)))

    (defun notmuch-refresh-file (id)
      (interactive (list (read-string "Which id? ")))
      (let ((thread-id
             (replace-regexp-in-string
              "\\n" ""
              (shell-command-to-string
               (format "notmuch search --output=threads id:%s" id)))))
        (shell-command (format "notmuch reindex %s" thread-id)))
      (shell-command (format "notmuch reindex id:%s" id)))

    (defun notmuch-show-goto-file ()
      (interactive)
      (find-file (notmuch-show-get-filename))))

  (use-exwm
    :config
    (defvar offlineimap-timer nil)
    (defvar offlineimap-process nil)

    (defun run-offlineimap ()
      (interactive)
      (if (and (processp offlineimap-process)
               (process-live-p offlineimap-process))
          (message "offlineimap already running...")
        (message "offlineimap starting...")
        (when (and (timerp offlineimap-timer)
                   (not (timer--triggered offlineimap-timer)))
          (cancel-timer offlineimap-timer))
        (call-process-shell-command "timedatectl" nil "*offlineimap-output*")
        (set-process-sentinel
         (setq offlineimap-process
               (start-process-shell-command "offlineimap" "*offlineimap-output*" "offlineimap"))
         #'(lambda (process event)
             (when (string-match-p "exited abnormally with code 1" event)
               (with-current-buffer (process-buffer offlineimap-process)
                 (when (string-match-p "get_password_emacs"(buffer-string))
                   (erase-buffer)
                   (message "Oops, didn't grab a password. ")
                   (setq offlineimap-timer (run-with-timer 300 nil #'run-offlineimap)))))
             (when (string-match-p "^finished" event)
               (message "Offlineimap finished")
               (setq offlineimap-timer (run-with-timer 300 nil #'run-offlineimap)))))))

    (defun stop-offlineimap ()
      (interactive)
      (when (timerp offlineimap-timer)
        (cancel-timer offlineimap-timer))
      (when (processp offlineimap-process)
        (set-process-sentinel offlineimap-process
                              nil)))

    (add-to-list 'exwm-init-hook
                 #'run-offlineimap
                 t))
#+end_src
** erc
#+begin_src emacs-lisp
  (use-package erc)
  (use-package erc-hl-nicks)
  (use-package erc-colorize)
  (require 'netrc)
  (erc-hl-nicks-mode)
  (erc-colorize-mode)
  (setq erc-user-full-name "Benson Chu")
  (setq erc-kill-buffer-on-part t)
  (setq erc-autojoin-channels-alist
        '(("freenode.net" "#emacs" "#org-mode"
           ;; "##linux" "#compilers" "#pltclub"
           ;; "##cs" "##computerscience" "##programming" "#lisp" "##lisp"
           ;; "#sbcl" "#ecl"
           )))

  (defun get-authinfo (host port)
    (let* ((netrc (netrc-parse (expand-file-name "~/.emacs.d/secrets/.authinfo.gpg")))
           (hostentry (netrc-machine netrc host port)))
      (when hostentry (netrc-get hostentry "password"))))

  (defun freenode-connect (nick password)
    (erc :server "irc.freenode.net" :port 6667
         :password password :nick nick))

  (defun irc-connect ()
    (interactive)
    (when (y-or-n-p "Connect to IRC? ")
      (freenode-connect "pest-ctrl" (get-authinfo "irc.freenode.net" "6667"))))
#+end_src
* pdf-tools use isearch
#+BEGIN_SRC emacs-lisp
  (when (not (eq system-type 'windows-nt))
    (use-package pdf-tools)
    (pdf-tools-install)
    (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
    (define-key pdf-view-mode-map (kbd "d") (lambda () (interactive) (pdf-view-next-line-or-next-page 8)))
    (define-key pdf-view-mode-map (kbd "u") (lambda () (interactive) (pdf-view-previous-line-or-previous-page 8))))
  #+END_SRC
* freezing time
#+begin_src emacs-lisp
  (defvar my/frozen-time nil)

  (defvar my/format-time-string-function nil)

  (defun my/org-today ()
    (time-to-days my/frozen-time))

  (defun my/current-time ()
    my/frozen-time)

  (defun my/format-time-string (original format-string &optional time zone)
    (apply original
           format-string
           (if time
               time
             my/frozen-time)
           zone))

  (defun my/decode-time (original &optional time zone)
    (apply original
           (if time
               time
             my/frozen-time)
           zone))

  ;; Change and freeze time
  (defun za-warudo ()
    "Freeze `current-time' at the current active or inactive timestamp. If point
  is not on a timestamp, the function prompts for one. If time is not specified,
  either by the timstamp under point or prompt, the time defaults to the
  current HH:MM of today at the selected date."
    (interactive)
    (let* ((org-read-date-prefer-future nil)
           (time (org-read-date t 'totime nil "Input freeze time: ")))
      (setq my/frozen-time (append time '(0 0)))
      (advice-add #'current-time :override #'my/current-time)
      (advice-add #'format-time-string :around #'my/format-time-string)
      (advice-add #'decode-time :around #'my/decode-time)
      (advice-add #'org-today :override #'my/org-today)
      (set-face-background 'fringe "firebrick2")
      (message "Toki yo tomare")))

  (define-key *root-map* (kbd "C-z") 'za-warudo)

  ;; Release changed / frozen time
  (defun un-za-warudo ()
    "Release the time frozen by `freeze-time'."
    (interactive)
    (advice-remove #'current-time #'my/current-time)
    (advice-remove #'format-time-string #'my/format-time-string)
    (advice-remove #'decode-time #'my/decode-time)
    (advice-remove #'org-today #'my/org-today)
    (setq my/frozen-time nil)
    (set-face-background 'fringe nil)
    (message "Soshite, toki wa ugoki dasu"))

  (define-key *root-map* (kbd "C-r") 'un-za-warudo)
#+end_src
* colorful compilation buffer
#+begin_src emacs-lisp
  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (let ((buffer-read-only nil))
      (ansi-color-apply-on-region (point-min) (point-max))))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+end_src
#+end_src
* New
** transpose-frame
#+begin_src emacs-lisp
  (use-package transpose-frame)
#+end_src
** e2wm
#+begin_src emacs-lisp
  (use-package e2wm
    :bind (("M-+" . e2wm:start-management)))
#+end_src
** Youtube-dl
#+BEGIN_SRC emacs-lisp
  (when (executable-find "youtube-dl")
    (add-to-list 'load-path "~/.emacs.d/submodule/youtube-dl-emacs/")
    (require 'youtube-dl)

    (defun youtube-dl-song (url)
      (interactive
       (list (read-from-minibuffer
              "URL: " (or (thing-at-point 'url)
                          (when interprogram-paste-function
                            (funcall interprogram-paste-function))))))
      (async-shell-command (format "youtube-dl -x -f \"bestaudio[ext=m4a]\" \"%s\"; tageditor -s album=\"youtube-dl\" -f *.m4a" url))))
#+END_SRC
** set-default-directory
#+begin_src emacs-lisp
  (defun set-default-directory (dir)
    (interactive "f")
    (setq default-directory dir))
#+end_src
** World time include Taiwan
#+begin_src emacs-lisp
  (setq display-time-world-list
        '(("America/Chicago" "Houston")
          ("Asia/Taipei" "Taiwan")))
#+end_src
** auto-save files in same directory
#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . "~/.emacs.d/backups/")))

  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        )
#+end_src
** Scroll interval
#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 1
        hscroll-margin 2
        hscroll-step 1
        scroll-conservatively 101
        scroll-preserve-screen-position t
        mouse-wheel-scroll-amount '(3)
        mouse-wheel-progressive-speed nil)
#+END_SRC
** Profiler Keymap
#+begin_src emacs-lisp
  (define-prefix-command '*profiler-map*)

  (define-key *profiler-map* (kbd "s") #'profiler-start)
  (define-key *profiler-map* (kbd "r") #'profiler-report)
  (define-key *profiler-map* (kbd "S") #'profiler-stop)

  (define-key *root-map* (kbd "p") '*profiler-map*)
#+end_src
** Open dev workspace
#+begin_src emacs-lisp
  (defun open-dev-workspace ()
    (interactive)
    (dired "~/big_files/workspace"))
#+end_src
** Helpful view-mode
#+begin_src emacs-lisp
  (defun helpful--navigate-view-mode (orig button)
    (let ((w (window-parameter (selected-window) 'quit-restore)))
      (funcall orig button)
      (view-mode)
      (setq-local view-exit-action
                  `(lambda (&rest args)
                     (set-window-parameter (selected-window) 'quit-restore ',w)))))

  (advice-add #'helpful--navigate
              :around
              #'helpful--navigate-view-mode)
#+end_src
** man select window
#+begin_src emacs-lisp
  (setq Man-notify-method 'aggressive)
#+end_src
** find-file-view
#+begin_src emacs-lisp
  (defun view-file ()
    (interactive)
    (call-interactively #'ido-find-file)
    (view-mode))

  (global-set-key (kbd "C-c C-v") #'view-file)
#+end_src
** rmsbolt
#+begin_src emacs-lisp
(use-package rmsbolt)
#+end_src
** ivy-posframe
#+begin_src emacs-lisp
  (require 'cl)

  (unless my-ec/at-ti
    (use-package ivy-posframe
      :config
      (setq ivy-posframe-display-functions-alist
            '((swiper          . ivy-posframe-display-at-frame-center)
              (complete-symbol . ivy-posframe-display-at-point)
              (iwc-switch-to-wc . nil)
              (t               . ivy-posframe-display-at-window-top-center)))

      (defun ivy-posframe-display-at-window-top-center (str)
        (ivy-posframe--display str #'posframe-poshandler-window-top-center))

      (defun posframe-poshandler-window-top-center (info)
        "Posframe's position handler.

    Get a position which let posframe stay onto current window's
    center.  The structure of INFO can be found in docstring
    of `posframe-show'."
        (let* ((frame-width (plist-get info :parent-frame-width))
               (window-left (plist-get info :parent-window-left))
               (window-top (plist-get info :parent-window-top))
               (window-width (plist-get info :parent-window-width))
               (posframe-width (plist-get info :posframe-width)))
          (cons (min (- frame-width posframe-width)
                     (+ window-left (max 0
                                         (/ (- window-width posframe-width) 2))))
                (+ window-top 50))))

      (defun disable-ivy-posframe-on-exwm-windows (orig &rest args)
        (if (not (eq major-mode 'exwm-mode))
            (apply orig args)
          (cl-letf (((symbol-function 'display-graphic-p) (lambda (&optional display) nil)))
            (apply orig args))))

      (advice-add #'ivy-posframe--read
                  :around
                  #'disable-ivy-posframe-on-exwm-windows))


    (unless (eq 'hash-table (type-of face-new-frame-defaults))

      ;; (def-face-copier my/posframe-faces (sym)
      ;;   (let ((name (symbol-name sym)))
      ;;     (string-match-p "^ivy-.*"
      ;;                     name)))

      ;;(setq ivy-posframe-min-height 0)

      ;; (setq ivy-posframe-height 24)

      ;; (setq ivy-height-alist
      ;;       '((t . 24)))
      ;; (setq ivy-posframe-height-alist
      ;;       '((counsel-M-x . 8)
      ;;         (t . 24)))
      ;; '((swiper . 24)))
      ))

  (use-package ivy-rich
    :requires ivy
    :config
    (ivy-rich-mode 1))
#+end_src
** Elfeed
#+begin_src
  (require 'elfeed)
  (setq elfeed-use-curl t)
  (elfeed-set-timeout 36000)
  (setq elfeed-curl-extra-arguments '("--insecure"))

  ;; enable elfeed-protocol
  (elfeed-protocol-enable)
#+end_src
** pavucontrol switch speakers headphones
#+begin_src emacs-lisp
  (require 'cl)

  (defvar laptop-sink-index 0)
  (defvar hdmi-pcie-interface nil)

  (defun setup-headphone-stuff ()
    (interactive)
    (let* ((result (shell-command-to-string "pactl list short sinks")))
      (when (string-match "\\([0-9]\\).*analog-stereo" result)
        (setq laptop-sink-index
              (string-to-number
               (match-string 1 result))))
      (when (string-match "[0-9].*\\(pci-.*\\)\\.hdmi-stereo" result)
        (setq hdmi-pcie-interface
              (match-string 1 result))))

    (when hdmi-pcie-interface
      (let* ((result (shell-command-to-string "pacmd list-modules"))
             (split (cdr (split-string result "index: "))))
        (cl-loop for mod in split
                 while (not
                        (string-match (format "\\([0-9]+\\)\n.*\n.*name=\"%s\"" hdmi-pcie-interface)
                                      mod))
                 finally
                 do (shell-command
                     (format "pactl unload-module %s"
                             (match-string 1 mod)))))))

  (defun current-speakers ()
    (let ((string (shell-command-to-string "pactl list sinks | grep 'Active Port: '")))
      (if (string-match-p "headphones" string)
          'headphones
        'speakers)))

  (defun toggle-audio-output ()
    (interactive)
    (if (eq (current-speakers)
            'headphones)
        (shell-command (format "pactl set-sink-port %d analog-output-speaker"
                               laptop-sink-index))
      (shell-command (format "pactl set-sink-port %d analog-output-headphones"
                             laptop-sink-index)))
    (message (format "Switched to: %s" (current-speakers))))

  (exwm-global-set-key (kbd "s-s") #'toggle-audio-output)

  (use-exwm
    :config
    (add-hook 'exwm-init-hook #'setup-headphone-stuff))
#+end_src
** shell-command+
#+begin_src emacs-lisp
  (use-package shell-command+
    :bind ("M-!" . shell-command+))
#+end_src
** shackle-mode
#+begin_src emacs-lisp
  (use-package shackle)

  (defun shackle--display-buffer-reuse (buffer alist)

    (let ((window (display-buffer-reuse-window buffer
                                               ;; Reuse frames
                                               (cons '(reusable-frames . t) alist))))
      (prog1 window
        (when (and window (window-live-p window)
                   shackle-select-reused-windows)
          (select-window window)))))

  (setq switch-to-buffer-obey-display-actions t
        shackle-select-reused-windows t)
  (setq shackle-rules '(("the_plan" :select t)))

  (shackle-mode 1)

  (defun get-the-plan ()
    (with-current-buffer (find-file-noselect "~/MEGA/org/agenda/plan.org")
      (rename-buffer "the_plan")
      (current-buffer)))

  (defun the-plan ()
    (interactive)
    (switch-to-buffer (get-the-plan)))

  (exwm-global-set-key (kbd "s-p") #'the-plan)
#+end_src
** Emojis!
#+begin_src emacs-lisp
  (use-package emojify)
#+end_src
** Window splitting function
#+begin_src emacs-lisp
  (defun split-window-sensibly-prefer-horizontal (&optional window)
    "Based on split-window-sensibly, but designed to prefer a horizontal split,
  i.e. windows tiled side-by-side."
    (let ((window (or window (selected-window))))
      (or (and (window-splittable-p window t)
               ;; Split window horizontally
               (with-selected-window window
                 (split-window-right)))
          (and (window-splittable-p window)
               ;; Split window vertically
               (with-selected-window window
                 (split-window-below)))
          (and
           ;; If WINDOW is the only usable window on its frame (it is
           ;; the only one or, not being the only one, all the other
           ;; ones are dedicated) and is not the minibuffer window, try
           ;; to split it horizontally disregarding the value of
           ;; `split-height-threshold'.
           (let ((frame (window-frame window)))
             (or
              (eq window (frame-root-window frame))
              (catch 'done
                (walk-window-tree (lambda (w)
                                    (unless (or (eq w window)
                                                (window-dedicated-p w))
                                      (throw 'done nil)))
                                  frame)
                t)))
           (not (window-minibuffer-p window))
           (let ((split-width-threshold 0))
             (when (window-splittable-p window t)
               (with-selected-window window
                 (split-window-right))))))))

  (defun split-window-really-sensibly (&optional window)
    (let ((window (or window (selected-window))))
      (if (> (window-total-width window) (* 2 (window-total-height window)))
          (with-selected-window window (split-window-sensibly-prefer-horizontal window))
        (with-selected-window window (split-window-sensibly window)))))

  (setq
     split-height-threshold 4
     split-width-threshold 40
     split-window-preferred-function 'split-window-really-sensibly)

#+end_src
